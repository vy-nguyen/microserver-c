/**
* Simple API
* A simple API to demonstrate OpenAPI to C++ stub generation.
*
* The version of the OpenAPI document: 1.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "IdKind.h"
#include "Helpers.h"
#include <stdexcept>
#include <sstream>

namespace org::openapitools::server::model
{

IdKind::IdKind()
{
    
}

void IdKind::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool IdKind::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool IdKind::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "IdKind" : pathPrefix;

    
    if (m_value == IdKind::eIdKind::INVALID_VALUE_OPENAPI_GENERATED)
    {
        success = false;
        msg << _pathPrefix << ": has no value;";
    }

    return success;
}

bool IdKind::operator==(const IdKind& rhs) const
{
    return
    getValue() == rhs.getValue()
    
    ;
}

bool IdKind::operator!=(const IdKind& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const IdKind& o)
{
    j = nlohmann::json::object();
    
    switch (o.getValue())
    {
        case IdKind::eIdKind::INVALID_VALUE_OPENAPI_GENERATED:
            j = "INVALID_VALUE_OPENAPI_GENERATED";
            break;
        case IdKind::eIdKind::UCAT:
            j = "ucat";
            break;
        case IdKind::eIdKind::SELL:
            j = "sell";
            break;
        case IdKind::eIdKind::BUYER:
            j = "buyer";
            break;
        case IdKind::eIdKind::CUST:
            j = "cust";
            break;
        case IdKind::eIdKind::CUSER:
            j = "cuser";
            break;
        case IdKind::eIdKind::PROF:
            j = "prof";
            break;
        case IdKind::eIdKind::USEC:
            j = "usec";
            break;
        case IdKind::eIdKind::UWAR:
            j = "uwar";
            break;
        case IdKind::eIdKind::UCON:
            j = "ucon";
            break;
        case IdKind::eIdKind::UPRD:
            j = "uprd";
            break;
        case IdKind::eIdKind::UTRX:
            j = "utrx";
            break;
        case IdKind::eIdKind::UWRK:
            j = "uwrk";
            break;
        case IdKind::eIdKind::DLTX:
            j = "dltx";
            break;
        case IdKind::eIdKind::DEAL:
            j = "deal";
            break;
        case IdKind::eIdKind::REFS:
            j = "refs";
            break;
        case IdKind::eIdKind::FEED:
            j = "feed";
            break;
        case IdKind::eIdKind::MESG:
            j = "mesg";
            break;
        case IdKind::eIdKind::BLOG:
            j = "blog";
            break;
        case IdKind::eIdKind::ART:
            j = "art";
            break;
        case IdKind::eIdKind::BOOK:
            j = "book";
            break;
        case IdKind::eIdKind::CHAPTER:
            j = "chapter";
            break;
        case IdKind::eIdKind::STR:
            j = "str";
            break;
        case IdKind::eIdKind::FAV:
            j = "fav";
            break;
        case IdKind::eIdKind::EMPTY:
            j = "";
            break;
    }
}

void from_json(const nlohmann::json& j, IdKind& o)
{
    
    auto s = j.get<std::string>();
    if (s == "ucat") {
     o.setValue(IdKind::eIdKind::UCAT);
    } 
    else if (s == "sell") {
     o.setValue(IdKind::eIdKind::SELL);
    } 
    else if (s == "buyer") {
     o.setValue(IdKind::eIdKind::BUYER);
    } 
    else if (s == "cust") {
     o.setValue(IdKind::eIdKind::CUST);
    } 
    else if (s == "cuser") {
     o.setValue(IdKind::eIdKind::CUSER);
    } 
    else if (s == "prof") {
     o.setValue(IdKind::eIdKind::PROF);
    } 
    else if (s == "usec") {
     o.setValue(IdKind::eIdKind::USEC);
    } 
    else if (s == "uwar") {
     o.setValue(IdKind::eIdKind::UWAR);
    } 
    else if (s == "ucon") {
     o.setValue(IdKind::eIdKind::UCON);
    } 
    else if (s == "uprd") {
     o.setValue(IdKind::eIdKind::UPRD);
    } 
    else if (s == "utrx") {
     o.setValue(IdKind::eIdKind::UTRX);
    } 
    else if (s == "uwrk") {
     o.setValue(IdKind::eIdKind::UWRK);
    } 
    else if (s == "dltx") {
     o.setValue(IdKind::eIdKind::DLTX);
    } 
    else if (s == "deal") {
     o.setValue(IdKind::eIdKind::DEAL);
    } 
    else if (s == "refs") {
     o.setValue(IdKind::eIdKind::REFS);
    } 
    else if (s == "feed") {
     o.setValue(IdKind::eIdKind::FEED);
    } 
    else if (s == "mesg") {
     o.setValue(IdKind::eIdKind::MESG);
    } 
    else if (s == "blog") {
     o.setValue(IdKind::eIdKind::BLOG);
    } 
    else if (s == "art") {
     o.setValue(IdKind::eIdKind::ART);
    } 
    else if (s == "book") {
     o.setValue(IdKind::eIdKind::BOOK);
    } 
    else if (s == "chapter") {
     o.setValue(IdKind::eIdKind::CHAPTER);
    } 
    else if (s == "str") {
     o.setValue(IdKind::eIdKind::STR);
    } 
    else if (s == "fav") {
     o.setValue(IdKind::eIdKind::FAV);
    } 
    else if (s == "") {
     o.setValue(IdKind::eIdKind::EMPTY);
    }  else {
     std::stringstream ss;
     ss << "Unexpected value " << s << " in json"
        << " cannot be converted to enum of type"
        << " IdKind::eIdKind";
     throw std::invalid_argument(ss.str());
    } 

}

IdKind::eIdKind IdKind::getValue() const
{
    return m_value;
}
void IdKind::setValue(IdKind::eIdKind value)
{
    m_value = value;
}

} // namespace org::openapitools::server::model

